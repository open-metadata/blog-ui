import { addArticleJsonLd } from '@starter-kit/utils/seo/addArticleJsonLd';
import { getAutogeneratedPostOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticPaths, GetStaticProps } from 'next';
import dynamic from 'next/dynamic';
import ErrorPage from 'next/error';
import Head from 'next/head';
import { Container } from '../components/container';
import { AppProvider, useAppContext } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { MarkdownToHtml } from '../components/markdown-to-html';
import { PostHeader } from '../components/post-header';
import {
	PageByPublicationDocument,
	PageByPublicationQuery,
	PageByPublicationQueryVariables,
	PostFullFragment,
	PublicationFragment,
	SinglePostByPublicationDocument,
	SinglePostByPublicationQuery,
	SinglePostByPublicationQueryVariables,
	SlugPostsByPublicationDocument,
	SlugPostsByPublicationQuery,
	SlugPostsByPublicationQueryVariables,
	StaticPageFragment,
} from '../generated/graphql';
// @ts-ignore
import handleMathJax from '@starter-kit/utils/handle-math-jax';
import { useEmbeds } from '@starter-kit/utils/renderer/hooks/useEmbeds';
import { loadIframeResizer } from '@starter-kit/utils/renderer/services/embed';
import { useEffect, useState } from 'react';
// @ts-ignore
import { triggerCustomWidgetEmbed } from '@starter-kit/utils/trigger-custom-widget-embed';
import { useRouter } from 'next/router';
import ParamLink from '../components/ParamLink';
import { Avatar } from '../components/avatar';
import { DateFormatter } from '../components/date-formatter';
import { ReadTimeInMinutes } from '../components/post-read-time-in-minutes';
import HeaderDev from '../components/header/HeaderDev';

const PostComments = dynamic(() =>
	import('../components/post-comments').then((mod) => mod.PostComments),
);

type Props =
	| {
			post: PostFullFragment;
			page: null;
			publication: PublicationFragment;
	  }
	| {
			post: null;
			page: StaticPageFragment;
			publication: PublicationFragment;
	  };

const Post = (publication: PublicationFragment, post: PostFullFragment) => {
	const highlightJsMonokaiTheme =
		'.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}';

	const tagsList = (post.tags ?? []).map((tag) => (
		<li key={tag.id}>
			<ParamLink
				href={`/tag/${tag.slug}`}
				className="block rounded-full border px-2 py-1 font-medium hover:bg-slate-50 dark:border-neutral-800 dark:hover:bg-neutral-800 md:px-4"
				name={`#${tag.slug}`}
			/>
		</li>
	));
	const [, setMobMount] = useState(false);
	const [canLoadEmbeds, setCanLoadEmbeds] = useState(false);

	const router = useRouter();

	useEmbeds({ enabled: canLoadEmbeds });
	if (post.hasLatexInPost) {
		setTimeout(() => {
			handleMathJax(true);
		}, 500);
	}

	useEffect(() => {
		if (screen.width <= 425) {
			setMobMount(true);
		}

		if (!post) {
			return;
		}

		// TODO:
		// More of an alert, did this below to wrap async funcs inside useEffect
		(async () => {
			await loadIframeResizer();
			triggerCustomWidgetEmbed(post.publication?.id.toString());
			setCanLoadEmbeds(true);
		})();
	}, [post]);

	return (
		<>
			<Head>
				<title>{post.seo?.title || post.title}</title>
				<link rel="canonical" href={post.url} />
				<meta name="description" content={post.seo?.description || post.subtitle || post.brief} />
				<meta property="twitter:card" content="summary_large_image" />
				<meta property="twitter:title" content={post.seo?.title || post.title} />
				<meta
					property="twitter:description"
					content={post.seo?.description || post.subtitle || post.brief}
				/>
				<meta
					property="og:image"
					content={
						post.ogMetaData?.image ||
						post.coverImage?.url ||
						getAutogeneratedPostOG(post, publication)
					}
				/>
				<meta
					property="twitter:image"
					content={
						post.ogMetaData?.image ||
						post.coverImage?.url ||
						getAutogeneratedPostOG(post, publication)
					}
				/>
				<script
					type="application/ld+json"
					dangerouslySetInnerHTML={{
						__html: JSON.stringify(addArticleJsonLd(publication, post)),
					}}
				/>
				<style dangerouslySetInnerHTML={{ __html: highlightJsMonokaiTheme }}></style>
			</Head>
			<div className="grid grid-cols-6 pt-10 lg:pt-0">
				<div className="col-span-full lg:col-span-4">
					<div className="mb-2">
						<button
							onClick={() => router.back()}
							className="flex cursor-pointer items-center gap-2"
						>
							<span>
								<svg
									xmlns="http://www.w3.org/2000/svg"
									fill="none"
									viewBox="0 0 24 24"
									strokeWidth={2}
									stroke="currentColor"
									className="h-4 w-4"
								>
									<path
										strokeLinecap="round"
										strokeLinejoin="round"
										d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
									/>
								</svg>
							</span>
							<span>Back</span>
						</button>
					</div>
					<PostHeader
						title={post.title}
						coverImage={post.coverImage?.url}
						date={post.publishedAt}
						author={post.author}
						readTimeInMinutes={post.readTimeInMinutes}
					/>
					<MarkdownToHtml contentMarkdown={post.content.markdown} />
					{(post.tags ?? []).length > 0 && (
						<div className="my-3 px-5 text-[#414651] dark:text-neutral-300 lg:hidden">
							<ul className="flex flex-row flex-wrap items-center gap-2">{tagsList}</ul>
						</div>
					)}
					{!post.preferences.disableComments && post.comments.totalDocuments > 0 && (
						<PostComments />
					)}
				</div>
				<div className="col-span-2 hidden lg:block">
					<div className="sticky top-24 mb-4 w-full px-5">
						<div className="w-full rounded-2xl border p-5 text-base leading-snug dark:border-neutral-800 dark:text-neutral-50">
							<Avatar
								username={post.author.username}
								name={post.author.name}
								size={8}
								picture={post.author.profilePicture}
							/>
							<div className="mb-4 mt-2 flex w-full flex-row flex-wrap  items-center gap-2 px-2 text-[#717680] dark:text-neutral-300 md:px-0">
								<DateFormatter dateString={post.publishedAt} />
								{post.readTimeInMinutes && (
									<span className="block font-bold text-slate-500">&middot;</span>
								)}
								<ReadTimeInMinutes readTimeInMinutes={post.readTimeInMinutes} />
							</div>
							{(post.tags ?? []).length > 0 && (
								<div className="text-[#414651] dark:text-neutral-300">
									<ul className="flex flex-row flex-wrap items-center gap-2">{tagsList}</ul>
								</div>
							)}
						</div>
					</div>
				</div>
			</div>
		</>
	);
};

const Page = (page: StaticPageFragment) => {
	const title = page.title;
	return (
		<>
			<Head>
				<title>{title}</title>
			</Head>
			<MarkdownToHtml contentMarkdown={page.content.markdown} />
		</>
	);
};

type PostOrPageContentProps = {
	publication: PublicationFragment;
	post: PostFullFragment | null;
	page: StaticPageFragment | null;
};

const PostOrPageContent = ({ publication, post, page }: PostOrPageContentProps) => {
	const { isEmbedded } = useAppContext();

	if (!post && !page) {
		return <ErrorPage statusCode={404} />;
	}

	return (
		<Layout>
			{!isEmbedded && <HeaderDev />}
			<Container className="pt-24">
				<article className="flex flex-col items-start gap-10 pb-10">
					{post ? Post(publication, post) : Page(page!)}
				</article>
			</Container>
			{!isEmbedded && <Footer />}
		</Layout>
	);
};

export default function PostOrPage({ publication, post, page }: Props) {
	return (
		<AppProvider publication={publication} post={post}>
			<PostOrPageContent publication={publication} post={post} page={page} />
		</AppProvider>
	);
}
	

type Params = {
	slug: string;
};

export const getStaticProps: GetStaticProps<Props, Params> = async ({ params }) => {
	if (!params) {
		throw new Error('No params');
	}
	const data = await request<SinglePostByPublicationQuery, SinglePostByPublicationQueryVariables>(
		process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT,
		SinglePostByPublicationDocument,
		{
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
			slug: params.slug,
		},
	);

	// Extract the post data from the GraphQL response
	const publication = data.publication;
	if (!publication) {
		return {
			notFound: true,
		};
	}
	const post = publication.post;
	if (!post) {
		const staticPageData = await request<PageByPublicationQuery, PageByPublicationQueryVariables>(
			process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT,
			PageByPublicationDocument,
			{
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
				slug: params.slug,
			},
		);

		const page = staticPageData.publication?.staticPage;
		if (!page) {
			return {
				notFound: true,
			};
		}
		return {
			props: {
				post: null,
				page,
				publication,
			},
			revalidate: 1,
		};
	}

	return {
		props: {
			post,
			page: null,
			publication,
		},
		revalidate: 1,
	};
};

export const getStaticPaths: GetStaticPaths = async () => {
	const data = await request<SlugPostsByPublicationQuery, SlugPostsByPublicationQueryVariables>(
		process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT,
		SlugPostsByPublicationDocument,
		{
			first: 10,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const postSlugs = (data.publication?.posts.edges ?? []).map((edge) => edge.node.slug);

	return {
		paths: postSlugs.map((slug) => {
			return {
				params: {
					slug: slug,
				},
			};
		}),
		fallback: 'blocking',
	};
};
